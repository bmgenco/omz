# etwd(wd)
# setwd(aqua_directory)
# files<-list.files()
#
# a<-lapply(files, f.tmp1)
# dates<-lapply(files, f.tmp2)
# names(a)<-as.character(dates)
# rm(files, directory, dates)
test<-odz[,,1]
dim(obs)
dim(z)
z
test<-obs[,,1]
dim(test)
plot(test)
head(test)
summary(test)
str(test)
dim(test)
dim(lon)
dim(lat)
install.packages("plot3D")
plot3D(obs)
scatter3D(obs)
librar(Plot3d)
library("Plot3D")
library("plot3D")
scatter3D(obs)
dim(obs)
scatter3D(obs[1], obs[2], obs[3])
plot(obs[1])
plot(obs[2])
plot(obs[3])
scatter3D(obs[1:256,,,], obs[,1:230,], obs[,,1:50])
scatter3D(obs[(1:256),,], obs[,(1:230),], obs[,,(1:50)])
str(obs)
dim(obs)
dim(lat)
install.packages("tidync")
install.packages("tidync", dependencies = T)
f.ipak <- function(pkg){
# loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
# will install  packages listed , and their dependencies, if needed.
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}
# packages<-c("stars", "gridExtra", "cowplot", "sf", "ggspatial","stringr","sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "data.table", "reshape2", "RColorBrewer", "marmap", "extrafont", "oce", "MODIS", "measurements")  # set packages here
packages<-c("sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "HURDAT", "sf", "cmocean", "ncdf4", "plot3D", "tidync")
f.ipak(packages)
rm(f.ipak, packages)
knitr::opts_chunk$set(echo = FALSE)
dim(obs)
str(obs)
obs[,,1]
str(obs[,,1])
dim(obs[,,1])
z
lat
lon
obs[,,1:50]
scatter3D(obs[,,])
dim(obs)
dim(obs)[1]
test<-obs[1:dim(obs)[1],1,1]
test
test<-obs[1:dim(obs)[1],,]
test
x<-obs[1:dim(obs)[1],1,1]
y<-obs[1,1:dim(obs)[2],1]
z<-obsbs[1,1,1:dim(obs)[3]]
x<-obs[(1:dim(obs)[1]),1,1]
y<-obs[1,(1:dim(obs)[2]),1]
z<-obsbs[1,1,(1:dim(obs)[3])]
x<-obs[(1:dim(obs)[1]),1,1]
y<-obs[1,(1:dim(obs)[2]),1]
z<-obs[1,1,(1:dim(obs)[3])]
scatter3D(x,y,z)
y
x
z
x<-tidync(file.path(data_d, "odz_atlas/nc_depth.nc"))
file.path(data_d, "odz_atlas/nc_depth.nc")
rm(list=ls())
# relative directories
robj<-"r_objects"
fig<-"../../figures"
gis_data<-"../../data/gis_data"
# data_d<-"../../data/2018_data"
data_d<-"../../data"
ocean_color<-"../../data/ocean_color_bud"
bathy_d<-"../../data/bathy" # edit this
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
f.ipak <- function(pkg){
# loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
# will install  packages listed , and their dependencies, if needed.
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}
# packages<-c("stars", "gridExtra", "cowplot", "sf", "ggspatial","stringr","sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "data.table", "reshape2", "RColorBrewer", "marmap", "extrafont", "oce", "MODIS", "measurements")  # set packages here
packages<-c("sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "HURDAT", "sf", "cmocean", "ncdf4", "plot3D", "tidync")
f.ipak(packages)
rm(f.ipak, packages)
knitr::opts_chunk$set(echo = FALSE)
x<-tidync(file.path(data_d, "odz_atlas/nc_depth.nc"))
x
quit()
rm(list=ls())
# relative directories
robj<-"r_objects"
fig<-"../../figures"
gis_data<-"../../data/gis_data"
# data_d<-"../../data/2018_data"
data_d<-"../../data"
ocean_color<-"../../data/ocean_color_bud"
bathy_d<-"../../data/bathy" # edit this
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
f.ipak <- function(pkg){
# loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
# will install  packages listed , and their dependencies, if needed.
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}
# packages<-c("stars", "gridExtra", "cowplot", "sf", "ggspatial","stringr","sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "data.table", "reshape2", "RColorBrewer", "marmap", "extrafont", "oce", "MODIS", "measurements")  # set packages here
packages<-c("sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "HURDAT", "sf", "cmocean", "ncdf4", "plot3D", "tidync")
f.ipak(packages)
rm(f.ipak, packages)
knitr::opts_chunk$set(echo = FALSE)
# download from online. Basin is eastern pacific
# h<-get_hurdat(basin="EP")
# saveRDS(h, "r_objects/hurdat.R")
h<-readRDS("r_objects/hurdat.R")
### user defined: ####
# prior and post for time frame of woa or ODZ in days
function_variables$h.prior<-21
function_variables<-vector(mode="list") # for storing all function variables that may be dynamic or other wise
#
# # select an individual storm by name OR  key fromm hurdat, "h" datsetset
# f.select_ts<-function(key_id){
# # can use or operator io incle storm name
# x<-filter(h, Key == key_id)
# # assign(key_id, x)
# # rm(x, key_id)
# # x<-ls()
# # return(x[1])
# }
#
#
#
# # function to spatial select TS
# f.h_spatial-function(h, lat_max, lat_min, lon_min, lon_max){
#   #bound
#
#   return()
# }
#
# # function to spatial select odz actual in-situ data or secondary products
# f.odz_actual_spatial<-function(odz_a, lat_max, lat_min, lon_min, lon_max){}
#
# # function to spatial select woa actual in-situ data or secondary products
# f.woa_actual_spatial<-function(woa_a, lat_max, lat_min, lon_min, lon_max){}
#
# # function to spatial select odz interpolated products
# f.odz_interpolated_spatial<-function(odz_i, lat_max, lat_min, lon_min, lon_max){}
#
# # function to spatial select woa interpolated  products
# f.woa_interpolated_spatial<-function(woa_i, lat_max, lat_min, lon_min, lon_max){}
#
#
# f.select_up<-function()
#
### nc files ####
# list.files(file.path(data_d, "odz_atlas"))
#
# f.tmp1<-function(x){
#   y<-nc_open(x)
#   chl<-ncvar_get(y, 'chlor_a')
#   lon<-ncvar_get(y, 'lon')
#   lat<-ncvar_get(y, 'lat')
#   rownames(chl)<-lon
#   colnames(chl)<-lat
#   nc_close(y)
#   rm(y)
#   x<-chl
#   return(x)
# }
#
# f.tmp2<-function(x){
#   y<-nc_open(x)
#   # start<-ncatt_get(y, attname = 'time_coverage_start', varid = 0, verbose=F)
#   # start<-start$value
#   # start<-ymd_hms(start)
#   # start<-with_tz(start, tz="US/Mountain")
#
#   end<-ncatt_get(y, attname = 'time_coverage_end', varid = 0, verbose=F)
#   end<-end$value
#   end<-ymd_hms(end)
#   end<-with_tz(end, tz="US/Mountain")
#   # time<-c(start, end, (end-start))
#   day<-day(end)
#   nc_close(y)
#   # rm(y, start, end)
#   rm(y, end)
#
#   return(as.character(day))
#
#
#   lon<-ncvar_get(y, 'lon')
#   lat<-ncvar_get(y, 'lat')
#   rownames(chl)<-lon
#   colnames(chl)<-lat
#   nc_close(y)
#   rm(y)
#   x<-chl
#   return(x)
# }
#
# etwd(wd)
# setwd(aqua_directory)
# files<-list.files()
#
# a<-lapply(files, f.tmp1)
# dates<-lapply(files, f.tmp2)
# names(a)<-as.character(dates)
# rm(files, directory, dates)
### user defined: ####
# prior and post for time frame of woa or ODZ in days
function_variables$h.prior<-21
function_variables$h.post<-21
# Mike's  deliminations: Only need to go to 30 N and 150 W on one corner.  Also 80 W is far enough. .. (implied = 0 south so just use 0.00)
function_variables$h.lon_max<--90 # need to improve here
function_variables$h.lon_min<--150
function_variables$h.lat_max<-30
# function_variables$h.lat_min<-0
# radius around TS in km
function_variables$h.radi<-500
### dynamic ####
#from hurdat dataset
#
# function_variables$h.lat_max<-max(h$Lat)
function_variables$h.lat_min<-min(h$Lat)
# function_variables$h.lon_max<-max(h$Lon[h$Lon < 0])
# function_variables$h.lon_min<-min(h$Lon)
# function_variables$h.lat_max<-max(h$Lat)
Selection<-paste0("Lat (", function_variables$h.lat_min, ", ", function_variables$h.lat_max, ") Lon (", function_variables$h.lon_min, ", ", function_variables$h.lon_max,  ")")
x<-tidync(file.path(data_d, "odz_atlas/nc_depth.nc"))
x
#### option 2 tidync package ####
file<-(file.path(data_d, "odz_atlas/nc_depth.nc"))
x<-tidync(file)
y<-hyper_filter(file)
y
x
setwd(gis_data)
coastline<-st_read("./ne_50m_land/ne_50m_land.shp")
x<-filter(h, Status == "HU")
h.sf<- sf::st_as_sf(x, coords = c("Lon","Lat"), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
h.sf<-sf::st_crop(h.sf, c(xmin=function_variables$h.lon_min, ymin=function_variables$h.lat_min, xmax=function_variables$h.lon_max, ymax=function_variables$h.lat_max)) #subset by uset defined
rm(x)
# cl<-st_crop(coastline, xmin=-170, ymin=-20, xmax=-80, ymax=40) # change here based on desired figure size
cl<-st_crop(coastline, xmin=function_variables$h.lon_min, ymin=function_variables$h.lat_min, xmax=function_variables$h.lon_max, ymax=function_variables$h.lat_max)
m.coast <- ggplot()+ geom_sf(data =cl, size=0.5)+ theme(axis.title.x=element_blank(), axis.title.y=element_blank())+
theme_bw()+ theme(text = element_text(size =12))
#'Selection' variable created in different code cell
# option 1
m.map<-m.coast+geom_sf(mapping = aes(col=Wind), data=h.sf, size=.25)+ggtitle(paste0("Hurricanes: ", Selection))+ labs(color = "Wind speed (m/s)")
m.map
#option 2
m.map<-m.coast+geom_sf(mapping = aes(col=Wind), data=h.sf, size= .25)+scale_color_cmocean(name="dense", direction= 1)+ggtitle(paste0("Hurricanes: ", Selection)) + labs(color = "Wind speed (m/s)")
m.map
rm(m.map, m.coast, cl, Selection)
x
x<-tidync(file)
x
rm(x)
rm(y)
x<-tidync(file)
rm(x)
y<-hyper_filter(file)
rm(x)
rm(y)
x<-tidync(file)
y<-hyper_filter(x)
y
print(x)
f.ipak <- function(pkg){
# loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
# will install  packages listed , and their dependencies, if needed.
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}
# packages<-c("stars", "gridExtra", "cowplot", "sf", "ggspatial","stringr","sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "data.table", "reshape2", "RColorBrewer", "marmap", "extrafont", "oce", "MODIS", "measurements")  # set packages here
packages<-c("sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "HURDAT", "sf", "cmocean", "ncdf4", "plot3D", "tidync", "devtools", "stars", "ncmeta", "maps")
f.ipak(packages)
rm(f.ipak, packages)
knitr::opts_chunk$set(echo = FALSE)
f.ipak <- function(pkg){
# loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
# will install  packages listed , and their dependencies, if needed.
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}
# packages<-c("stars", "gridExtra", "cowplot", "sf", "ggspatial","stringr","sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "data.table", "reshape2", "RColorBrewer", "marmap", "extrafont", "oce", "MODIS", "measurements")  # set packages here
#tidyverse is all of the following packages: ggplot2, dplyr, tidyr, readr, purr, tibble, sringr, & forcats.
packages<-c("sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "lubridate",  "ggthemes", "HURDAT", "sf", "cmocean", "ncdf4", "plot3D", "tidync", "devtools", "stars", "ncmeta", "maps")
f.ipak(packages)
rm(f.ipak, packages)
knitr::opts_chunk$set(echo = FALSE)
f.ipak <- function(pkg){
# loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
# will install  packages listed , and their dependencies, if needed.
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}
# packages<-c("stars", "gridExtra", "cowplot", "sf", "ggspatial","stringr","sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "data.table", "reshape2", "RColorBrewer", "marmap", "extrafont", "oce", "MODIS", "measurements")  # set packages here
#tidyverse is all of the following packages: ggplot2, dplyr, tidyr, readr, purr, tibble, sringr, & forcats.
packages<-c("sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "lubridate",  "ggthemes", "HURDAT", "sf", "cmocean", "ncdf4", "RNetCDF",  "plot3D", "tidync", "devtools", "stars", "ncmeta", "maps")
f.ipak(packages)
rm(f.ipak, packages)
knitr::opts_chunk$set(echo = FALSE)
f.ipak <- function(pkg){
# loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
# will install  packages listed , and their dependencies, if needed.
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}
# packages<-c("stars", "gridExtra", "cowplot", "sf", "ggspatial","stringr","sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "data.table", "reshape2", "RColorBrewer", "marmap", "extrafont", "oce", "MODIS", "measurements")  # set packages here
#tidyverse is all of the following packages: ggplot2, dplyr, tidyr, readr, purr, tibble, sringr, & forcats.
packages<-c("sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "lubridate",  "ggthemes", "HURDAT", "sf", "cmocean", "ncdf4", "RNetCDF",  "plot3D", "tidync", "devtools", "stars", "ncmeta", "maps", "oce", "data.table")
f.ipak(packages)
rm(f.ipak, packages)
knitr::opts_chunk$set(echo = FALSE)
rm(list=ls())
knitr::opts_chunk$set(echo = FALSE)
# See: https://stackoverflow.com/questions/25721884/how-should-i-deal-with-package-xxx-is-not-available-for-r-version-x-y-z-wa
f.ipak <- function(pkg){
# loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
# will install  packages listed , and their dependencies, if needed.
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}
packages<-c("stars", "gridExtra", "cowplot", "sf", "ggspatial","stringr","sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "data.table", "reshape2", "RColorBrewer", "marmap", "extrafont", "oce", "MODIS", "measurements")  # set packages here
f.ipak(packages)
rm(f.ipak, packages)
# wd<-"/home/brandon/vestawd/omz/wd/r_wd"
setwd("..")
wd<-getwd()
robj<-"./r_objects"
fig<-"../../figures"
gis_data<-"../../data/gis_data"
data_d<-"../../data/2018_data"
ocean_color<-"../../data/ocean_color_bud"
bathy_d<-"../../data/bathy" # edit this
ctdata<-"../../data/2018_data/ctd/data"
fdata<-"../../data/2018_data/fluor/get.rvdata.us/cruise/OC1806A/fileset/129998/OC1806A/129998/data" # Cruise flow fluorometer
tdata<-"../../data/2018_data/temp/OC1806A/130001/data" # Cruise flow Temp
wdata<-"../../data/2018_data/anem/OC1806A/130002/data" # Cruise wind/anemometer
gps_data<-"../../data/2018_data/gnss/data" # Cruise gps raw
corrected_fdata<-"../../data/2018_data/fluor/corrected_fluorometer/FLOW_THROUGH-20210511T213127Z-001/FLOW_THROUGH/CHL"
knitr::opts_knit$set(root.dir=wd)
#### fluorometer functions ####
f.read_cruise<-function(directory){
files<-list.files(directory)
data<-vector(mode="list", length=length(files))
for(i in 1:length(files)){
data[[i]]<-read.delim(file.path(directory, files[i]), sep =",", header = F)
}
return(data)}
f.rearrange_temp<-function(x, c.names){
names(x)<-c.names
options("digits.secs"=3)
x$time<-mdy_hms(paste(x$`SCS UTC DATE`, x$`SCS UTC TIME`, tz="UTC"))
x$time<-with_tz(x$time, tz="US/Mountain")
x$date<-date(x$time)
x<-subset(x, select= c(date, time, `TEMPERATURE CELSIUS`))
x<-as_tibble(x)
names(x)<-c("date", "time", "celsius")
return(x)
}
f.rearrange_flr<-function(x, c.names){
names(x)<-c.names
options("digits.secs"=3)
x$time<-mdy_hms(paste(x$`SCS UTC DATE`, x$`SCS UTC TIME`, tz="UTC"))
x$time<-with_tz(x$time, tz="US/Mountain")
x$date<-date(x$time)
x<-subset(x, select= c(date, time,  `TRANSMISSOMETER RAW VOLTAGE`, `FLOUROMETER RAW VOLTAGE`, `SURFACE PAR RAW VOLTAGE`))
x<-as_tibble(x)
names(x)<-c("date", "time", "transmissometer", "fluorometer","PAR")
return(x)
}
f.rearrange_flr_corrected<-function(x){
options("digits.secs"=3)
x$time<-mdy_hms(paste(x[,1], x[,2], tz="UTC"))
x$time<-with_tz(x$time, tz="US/Mountain")
x$date<-date(x$time)
x<-subset(x, select= c(date, time,  V4))
x<-as_tibble(x)
names(x)<-c("date", "time", "chlorophyll")
return(x)
}
f.rearrange_wind<-function(x){
#names(x)<-c.names
options("digits.secs"=3)
x$time<-mdy_hms(paste(x$V1, x$V2, tz="UTC"))
x$time<-with_tz(x$time, tz="US/Mountain")
x$date<-date(x$time)
#x<-subset(x, select=c(date, time, V3, V4, V5, V6, V7,V8,V9,V10))
x<-subset(x, select=c(date, time, V5))
x<-as_tibble(x)
return(x)
}
#### gps functions ####
f.rearrange_gps<-function(x, c.names){
x<-x[,c(1,2,5,7)]
names(x)<-c.names
options("digits.secs"=3)
x$time<-mdy_hms(paste(x$date1, x$time1, tz="UTC"))
x$time<-with_tz(x$time, tz="US/Mountain")
x$date<-date(x$time)
x<-subset(x, select= c(date, time, lat, lon))
x<-as_tibble(x)
names(x)<-c("date", "time", "lat", "lon")
return(x)
} # requires env variable "c.names"
f.gps_lat<-function(data){
x<-data$lat
x<-format(round(x, digits=5), nsmall = 5)
x<-as.character(x)
p<-"(([0-9]{2})(?=\\.))"
r<-" \\1"
x<-str_replace_all(pattern=p, replacement = r, x)
x<-measurements::conv_unit(x, from='deg_dec_min', to ="dec_deg")
x<-as.numeric(x)
x<-format(round(x, digits=4), nsmall = 4)
data$lat<<-x
}
f.gps_lon<-function(data){
x<-data$lon
x<-format(round(x, digits=5), nsmall = 5)
x<-as.character(x)
p<-"(([0-9]{2})(?=\\.))"
r<-" \\1"
x<-str_replace_all(pattern=p, replacement = r, x)
x<-measurements::conv_unit(x, from='deg_dec_min', to ="dec_deg")
x<-as.numeric(x)
x<-format(round(x, digits=4), nsmall = 4)
data$lon<<-x
}
#### combination functions ####
f.time_join_flow<-function(f, t){
#for joining data by "nearest" time/date in seconds
#requires "data.table" package
setDT(f)
setDT(t)
setkey(f, time)
setkey(t, time)
f<-f[t, roll='nearest']
} #for spatial stations from flowthrough
f.time_join2_flow<-function(data, pos){
setDT(data)
setDT(pos)
setkey(data, time)
setkey(pos, time)
data<-data[pos, roll='nearest']
}
#### ctd functions ####
f.time_ctd<-function(x){
x$time<-with_tz(x$time, tz="US/Mountain")
return(x)} #for spatial stations from CTD centroids
f.cent_ctd<-function(x){
y<-SpatialPoints(coords=cbind(x$longitude, x$latitude), proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
x<-gCentroid(y)
x<-cbind(x@coords[1], x@coords[2])
return(x)} #for spatial stations from CTD centroids
f.mean_time_ctd<-function(x){
x<-with_tz(x$time, tzone="UTC")%>%as.numeric%>%mean
x<-with_tz(with_tz(as_datetime(x), tzone="UTC"), tzone="US/Mountain")
return(x)}  #for spatial stations from CTD centroids
# f.read_ctd<-function(ctdata){
#   files<-list.files(ctdata)
#   data<-vector(mode="list", length=length(files))
#
#   for(i in 1:length(files)){
#     # add if else statement
#     data[[i]]<-read.ctd(file.path(ctdata, files[]),)
#    # trim downcast
#     x<-ctdTrim(x, method = "downcast")
#     }
#
#
# return(data)} #for CTD data not used
# remote sensing functions
setwd(tdata)
list.files()
tdata
