x$time<-mdy_hms(paste(x$`SCS UTC DATE`, x$`SCS UTC TIME`, tz="UTC"))
x$time<-with_tz(x$time, tz="US/Mountain")
x$date<-date(x$time)
x<-subset(x, select= c(date, time,  `TRANSMISSOMETER RAW VOLTAGE`, `FLOUROMETER RAW VOLTAGE`, `SURFACE PAR RAW VOLTAGE`))
x<-as_tibble(x)
names(x)<-c("date", "time", "transmissometer", "fluorometer","PAR")
return(x)
}
f.rearrange_flr_corrected<-function(x){
options("digits.secs"=3)
x$time<-mdy_hms(paste(x[,1], x[,2], tz="UTC"))
x$time<-with_tz(x$time, tz="US/Mountain")
x$date<-date(x$time)
x<-subset(x, select= c(date, time,  V4))
x<-as_tibble(x)
names(x)<-c("date", "time", "chlorophyll")
return(x)
}
f.rearrange_wind<-function(x){
#names(x)<-c.names
options("digits.secs"=3)
x$time<-mdy_hms(paste(x$V1, x$V2, tz="UTC"))
x$time<-with_tz(x$time, tz="US/Mountain")
x$date<-date(x$time)
#x<-subset(x, select=c(date, time, V3, V4, V5, V6, V7,V8,V9,V10))
x<-subset(x, select=c(date, time, V5))
x<-as_tibble(x)
return(x)
}
#### gps functions ####
f.rearrange_gps<-function(x, c.names){
x<-x[,c(1,2,5,7)]
names(x)<-c.names
options("digits.secs"=3)
x$time<-mdy_hms(paste(x$date1, x$time1, tz="UTC"))
x$time<-with_tz(x$time, tz="US/Mountain")
x$date<-date(x$time)
x<-subset(x, select= c(date, time, lat, lon))
x<-as_tibble(x)
names(x)<-c("date", "time", "lat", "lon")
return(x)
} # requires env variable "c.names"
f.gps_lat<-function(data){
x<-data$lat
x<-format(round(x, digits=5), nsmall = 5)
x<-as.character(x)
p<-"(([0-9]{2})(?=\\.))"
r<-" \\1"
x<-str_replace_all(pattern=p, replacement = r, x)
x<-measurements::conv_unit(x, from='deg_dec_min', to ="dec_deg")
x<-as.numeric(x)
x<-format(round(x, digits=4), nsmall = 4)
data$lat<<-x
}
f.gps_lon<-function(data){
x<-data$lon
x<-format(round(x, digits=5), nsmall = 5)
x<-as.character(x)
p<-"(([0-9]{2})(?=\\.))"
r<-" \\1"
x<-str_replace_all(pattern=p, replacement = r, x)
x<-measurements::conv_unit(x, from='deg_dec_min', to ="dec_deg")
x<-as.numeric(x)
x<-format(round(x, digits=4), nsmall = 4)
data$lon<<-x
}
#### combination functions ####
f.time_join_flow<-function(f, t){
#for joining data by "nearest" time/date in seconds
#requires "data.table" package
setDT(f)
setDT(t)
setkey(f, time)
setkey(t, time)
f<-f[t, roll='nearest']
} #for spatial stations from flowthrough
f.time_join2_flow<-function(data, pos){
setDT(data)
setDT(pos)
setkey(data, time)
setkey(pos, time)
data<-data[pos, roll='nearest']
}
#### ctd functions ####
f.time_ctd<-function(x){
x$time<-with_tz(x$time, tz="US/Mountain")
return(x)} #for spatial stations from CTD centroids
f.cent_ctd<-function(x){
y<-SpatialPoints(coords=cbind(x$longitude, x$latitude), proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
x<-gCentroid(y)
x<-cbind(x@coords[1], x@coords[2])
return(x)} #for spatial stations from CTD centroids
f.mean_time_ctd<-function(x){
x<-with_tz(x$time, tzone="UTC")%>%as.numeric%>%mean
x<-with_tz(with_tz(as_datetime(x), tzone="UTC"), tzone="US/Mountain")
return(x)}  #for spatial stations from CTD centroids
# f.read_ctd<-function(ctdata){
#   files<-list.files(ctdata)
#   data<-vector(mode="list", length=length(files))
#
#   for(i in 1:length(files)){
#     # add if else statement
#     data[[i]]<-read.ctd(file.path(ctdata, files[]),)
#    # trim downcast
#     x<-ctdTrim(x, method = "downcast")
#     }
#
#
# return(data)} #for CTD data not used
# remote sensing functions
setwd(tdata)
list.files()
tdata
rm(list=ls())
# relative directories
robj<-"r_objects"
fig<-"../../figures"
gis_data<-"../../data/gis_data"
# data_d<-"../../data/2018_data"
data_d<-"../../data"
ocean_color<-"../../data/ocean_color_bud"
bathy_d<-"../../data/bathy" # edit this
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
f.ipak <- function(pkg){
# loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
# will install  packages listed , and their dependencies, if needed.
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}
# packages<-c("stars", "gridExtra", "cowplot", "sf", "ggspatial","stringr","sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "ggplot2", "lubridate",  "ggthemes", "data.table", "reshape2", "RColorBrewer", "marmap", "extrafont", "oce", "MODIS", "measurements")  # set packages here
#tidyverse is all of the following packages: ggplot2, dplyr, tidyr, readr, purr, tibble, sringr, & forcats.
packages<-c("sp", "rgdal",  "rgeos", "raster","readr" ,"tidyverse", "lubridate",  "ggthemes", "HURDAT", "sf", "cmocean", "ncdf4", "RNetCDF",  "plot3D", "tidync", "devtools", "stars", "ncmeta", "maps", "oce", "data.table")
f.ipak(packages)
rm(f.ipak, packages)
knitr::opts_chunk$set(echo = FALSE)
function_variables<-vector(mode="list") # for storing all function variables that may be dynamic or other wise
#
# # select an individual storm by name OR  key fromm hurdat, "h" datsetset
# f.select_ts<-function(key_id){
# # can use or operator io incle storm name
# x<-filter(h, Key == key_id)
# # assign(key_id, x)
# # rm(x, key_id)
# # x<-ls()
# # return(x[1])
# }
#
#
#
# # function to spatial select TS
# f.h_spatial-function(h, lat_max, lat_min, lon_min, lon_max){
#   #bound
#
#   return()
# }
#
# # function to spatial select odz actual in-situ data or secondary products
# f.odz_actual_spatial<-function(odz_a, lat_max, lat_min, lon_min, lon_max){}
#
# # function to spatial select woa actual in-situ data or secondary products
# f.woa_actual_spatial<-function(woa_a, lat_max, lat_min, lon_min, lon_max){}
#
# # function to spatial select odz interpolated products
# f.odz_interpolated_spatial<-function(odz_i, lat_max, lat_min, lon_min, lon_max){}
#
# # function to spatial select woa interpolated  products
# f.woa_interpolated_spatial<-function(woa_i, lat_max, lat_min, lon_min, lon_max){}
#
#
# f.select_up<-function()
#
### nc files ####
# list.files(file.path(data_d, "odz_atlas"))
#
# f.tmp1<-function(x){
#   y<-nc_open(x)
#   chl<-ncvar_get(y, 'chlor_a')
#   lon<-ncvar_get(y, 'lon')
#   lat<-ncvar_get(y, 'lat')
#   rownames(chl)<-lon
#   colnames(chl)<-lat
#   nc_close(y)
#   rm(y)
#   x<-chl
#   return(x)
# }
#
# f.tmp2<-function(x){
#   y<-nc_open(x)
#   # start<-ncatt_get(y, attname = 'time_coverage_start', varid = 0, verbose=F)
#   # start<-start$value
#   # start<-ymd_hms(start)
#   # start<-with_tz(start, tz="US/Mountain")
#
#   end<-ncatt_get(y, attname = 'time_coverage_end', varid = 0, verbose=F)
#   end<-end$value
#   end<-ymd_hms(end)
#   end<-with_tz(end, tz="US/Mountain")
#   # time<-c(start, end, (end-start))
#   day<-day(end)
#   nc_close(y)
#   # rm(y, start, end)
#   rm(y, end)
#
#   return(as.character(day))
#
#
#   lon<-ncvar_get(y, 'lon')
#   lat<-ncvar_get(y, 'lat')
#   rownames(chl)<-lon
#   colnames(chl)<-lat
#   nc_close(y)
#   rm(y)
#   x<-chl
#   return(x)
# }
#
# etwd(wd)
# setwd(aqua_directory)
# files<-list.files()
#
# a<-lapply(files, f.tmp1)
# dates<-lapply(files, f.tmp2)
# names(a)<-as.character(dates)
# rm(files, directory, dates)
setwd(gis_data)
coastline<-st_read("./ne_50m_land/ne_50m_land.shp")
# download from online. Basin is eastern pacific
# h<-get_hurdat(basin="EP")
# saveRDS(h, "r_objects/hurdat.R")
h<-readRDS("r_objects/hurdat.R")
rm(coastline)
### user defined: ####
# prior and post for time frame of woa or ODZ in days
function_variables$h.prior<-21
function_variables$h.post<-21
# Mike's  deliminations: Only need to go to 30 N and 150 W on one corner.  Also 80 W is far enough. .. (implied = 0 south so just use 0.00)
function_variables$h.lon_max<--90 # need to improve here
function_variables$h.lon_min<--150
function_variables$h.lat_max<-30
# function_variables$h.lat_min<-0
# radius around TS in km
function_variables$h.radi<-500
### dynamic ####
#from hurdat dataset
#
# function_variables$h.lat_max<-max(h$Lat)
function_variables$h.lat_min<-min(h$Lat)
# function_variables$h.lon_max<-max(h$Lon[h$Lon < 0])
# function_variables$h.lon_min<-min(h$Lon)
# function_variables$h.lat_max<-max(h$Lat)
Selection<-paste0("Lat (", function_variables$h.lat_min, ", ", function_variables$h.lat_max, ") Lon (", function_variables$h.lon_min, ", ", function_variables$h.lon_max,  ")")
x<-filter(h, Status == "HU")
h.sf<- sf::st_as_sf(x, coords = c("Lon","Lat"), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
h.sf<-sf::st_crop(h.sf, c(xmin=function_variables$h.lon_min, ymin=function_variables$h.lat_min, xmax=function_variables$h.lon_max, ymax=function_variables$h.lat_max)) #subset by uset defined
rm(x)
# from remote sensiong code. edit this
#### Option 1 netcdf: ####
# x<-nc_open(file.path(data_d, "odz_atlas/nc_depth.nc"))
# lat<-ncvar_get(x, "Latitude")
# lon<-ncvar_get(x, "Longitude")
# z<-ncvar_get(x, "Depth")
# obs<-ncvar_get(x, "numObs")
# nc_close(x)
#
# come back here:
# derivdepth<-ncvar_get(x, "maxDerivDepth")
# fodz<-ncvar_get(x, "fODZ")
# o2<-ncvar_get(x, "O2")
# test<-obs[,,1]
#
# x<-dim()
#
# scatter3D(obs[(1:256),,], obs[,(1:230),], obs[,,(1:50)])
#
# x<-obs[(1:dim(obs)[1]),1,1]
# y<-obs[1,(1:dim(obs)[2]),1]
# z<-obs[1,1,(1:dim(obs)[3])]
#
# scatter3D(x,y,z)
#
#### option 2 tidync package ####
file<-(file.path(data_d, "odz_atlas/nc_depth.nc"))
x<-tidync(file)
# y<-hyper_filter(x)
x
### user defined: ####
# prior and post for time frame of woa or ODZ in days
function_variables$h.prior<-21
function_variables$h.post<-21
# Mike's  deliminations: Only need to go to 30 N and 150 W on one corner.  Also 80 W is far enough. .. (implied = 0 south so just use 0.00)
function_variables$h.lon_max<--90 # need to improve here
function_variables$h.lon_min<--150
function_variables$h.lat_max<-30
# function_variables$h.lat_min<-0
# radius around TS in m
function_variables$h.radi<-100000
# # radius around TS in degrees
# function_variables$h.radi<-0.5
### dynamic ####
#from hurdat dataset
#
# function_variables$h.lat_max<-max(h$Lat)
function_variables$h.lat_min<-min(h$Lat)
# function_variables$h.lon_max<-max(h$Lon[h$Lon < 0])
# function_variables$h.lon_min<-min(h$Lon)
# function_variables$h.lat_max<-max(h$Lat)
Selection<-paste0("Lat (", function_variables$h.lat_min, ", ", function_variables$h.lat_max, ") Lon (", function_variables$h.lon_min, ", ", function_variables$h.lon_max,  ")")
function_variables
x<-h.sf
radi.m<-function_variables$h.radi
head(x)
x[1:20,]
h.sf
h.sf[1:20,]
print(h.sf[1:20,])
print(h.sf[1:20,], n=20)
# x<-h.sf
x<-h.sf[1:20,]
x
print(x, n=20)
x$geometry
x[1]
x[1,]
str(x[1,])
y<-x[1,]
y
test<-st_buffer(y, dist=10000)
test
plot(y)
ggplot(test)
test
print(test n=20)
print(test, n=20)
test$geometry
plot(test$geometry)
plot(y$geometry, add=t)
plot(y$geometry)
test<-st_buffer(y, dist=.25)
y<-x[1,]
y
lat0<-"18.5005"
lat0<-"-108.502"
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, "+lon_0=", lon0)
lon0<-"-108.502"
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, "+lon_0=", lon0)
center.reproj
y$geometry[1]
y$geometry[1,]
y$geometry[[1]]
y$geometry[[1]][1]
y$geometry[[1]][2]
lat0<-y$geometry[[1]][2]
lon0<-y$geometry[[1]][1]
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, "+lon_0=", lon0)
center.reproj
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
center.reproj
lat0<-y$geometry[[1]][2]
lon0<-y$geometry[[1]][1]
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
flat<-sf::st_transform(y, center.reproj )
circle<-sf::st_buffer(flat, dist=radi.m)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
circle
circle$geometry
lat0<-y$geometry[[1]][2]
lon0<-y$geometry[[1]][1]
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
flat<-sf::st_transform(y$geometry, center.reproj )
circle<-sf::st_buffer(flat, dist=radi.m)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
circle
y$buff<-circle
y
plot(y)
ggplot(y)
f.buffer_select<-function(h.sf, function_variables){
# x<-h.sf
x<-h.sf[1:20,]
radi.m<-function_variables$h.radi
f.circle<-function(x, radi.m){
lat0<-x$geometry[[1]][2]
lon0<-x$geometry[[1]][1]
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
flat<-sf::st_transform(x$geometry, center.reproj )
circle<-sf::st_buffer(flat, dist=radi.m)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
x$buffer<-circle
rm(flat, circle)
return(x)
}
x<-lapply(x, function=f.circle)
f.buffer_select<-function(h.sf, function_variables){
# x<-h.sf
x<-h.sf[1:20,]
radi.m<-function_variables$h.radi
f.circle<-function(x, radi.m){
lat0<-x$geometry[[1]][2]
lon0<-x$geometry[[1]][1]
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
flat<-sf::st_transform(x$geometry, center.reproj )
circle<-sf::st_buffer(flat, dist=radi.m)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
x$buffer<-circle
rm(flat, circle)
return(x)
}
x<-lapply(x, f.circle)
return(x)
}
test<-f.buffer_select((h.sf, function_variables))
test<-f.buffer_select(h.sf, function_variables)
test
ggplot(test)
tes
test
f.buffer_select<-function(h.sf, function_variables){
# x<-h.sf
x<-h.sf[1:20,]
radi.m<-function_variables$h.radi
f.circle<-function(x, radi.m){
lat0<-x$geometry[[1]][2]
lon0<-x$geometry[[1]][1]
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
flat<-sf::st_transform(x$geometry, center.reproj )
circle<-sf::st_buffer(flat, dist=radi.m)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
x$buffer<-circle
rm(flat, circle)
return(x)
}
y<-lapply(st_geometry(x), f.circle)
return(y)
}
test<-f.buffer_select(h.sf, function_variables)
1
st_geometry(x)
y
# x<-h.sf
x<-h.sf[1:20,]
x
y<-st_geometry(x)[1]
y
y[[1]][2]
f.buffer_select<-function(h.sf, function_variables){
# x<-h.sf
x<-h.sf[1:20,]
radi.m<-function_variables$h.radi
y<-st_geometry(x)
f.circle<-function(y, radi.m){
lat0<-y[[1]][2]
lon0<-y[[1]][1]
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
flat<-sf::st_transform(y, center.reproj )
circle<-sf::st_buffer(flat, dist=radi.m)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
return(circle)
}
z<-lapply(st_geometry(x), f.circle)
return(z)
}
test<-f.buffer_select(h.sf, function_variables)
f.buffer_select<-function(h.sf, function_variables){
# x<-h.sf
x<-h.sf[1:20,]
radi.m<-function_variables$h.radi
y<-st_geometry(x)
f.circle<-function(y, radi.m){
lat0<-y[[1]][2]
lon0<-y[[1]][1]
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
flat<-sf::st_transform(y, center.reproj )
circle<-sf::st_buffer(flat, dist=radi.m)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
return(circle)
}
z<-lapply(y, f.circle)
return(z)
}
test<-f.buffer_select(h.sf, function_variables)
y
y<-st_geometry(x)
y
f.circle<-function(y, radi.m){
lat0<-y[[1]][2]
lon0<-y[[1]][1]
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
flat<-sf::st_transform(y, center.reproj )
circle<-sf::st_buffer(flat, dist=radi.m)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
return(circle)
}
test<-f.circle(y, radi.m)
test
f.buffer_select<-function(h.sf, function_variables){
# x<-h.sf
x<-h.sf[1:20,]
radi.m<-function_variables$h.radi
y<-st_geometry(x)
f.circle<-function(y, radi.m){
lat0<-y[[1]][2]
lon0<-y[[1]][1]
center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
flat<-sf::st_transform(y, center.reproj )
circle<-sf::st_buffer(flat, dist=radi.m)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
return(circle)
}
z<-f.circle(y, radi.m)
x$buffer<-z
return(x)
}
test<-f.buffer_select(h.sf, function_variables)
test
h.buf<-f.buffer_select(h.sf, function_variables)
h.buff
h.buf
