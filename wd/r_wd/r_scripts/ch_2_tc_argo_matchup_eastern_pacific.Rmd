---
title: "ch2_TC_argo_match up"
output: html_document
date: '2023-09-12'
---
 
# Setup
## Directories and defaults

Ideally yous proj file for relative directories
see: https://yihui.org/knitr/options/

Directory structure  used in this analysis:

~/omz/wd
-- /output
-- /data
-- /figures
-- /r_wd

~/omz/wd/r_wd
-- /Index
-- /Profiles
-- /r_objects
-- /r_scripts


```{r setup}
rm(list=ls())

r_scriptwd<-getwd()
wd<-substring(r_scriptwd,1,nchar(r_scriptwd) -10) # hardcoding replace here
knitr::opts_knit$set(root.dir = wd)

# relative directories
robj<-"r_objects"
fig<-"../../figures"
gis_data<-"../../data/gis_data"
output<-"../../output"
data_d<-"../../data"

# ocean_color<-"../../data/ocean_color_bud"
# bathy_d<-"../../data/bathy" # edit this

knitr::opts_chunk$set(echo =FALSE)
#knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

## Packages

Installed custom hurdat package using r markdown menu
* download  tar from archive as no longer maintained on cran repository
* https://cran.r-project.org/src/contrib/Archive/HURDAT/
+ include as git submodule instead

```{r}
wd<-getwd()

f.ipak <- function(pkg){
  # loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
  # will install  packages listed , and their dependencies, if needed.
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg))
    install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
  sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}

packages<-c("plyr","sp", "rgdal",  "rgeos", "raster", "readr", "tidyverse", "lubridate",  "ggthemes",  "sf", "cmocean", "ncdf4", "RNetCDF",  "plot3D", "tidync", "devtools", "stars", "ncmeta", "maps", "oce", "data.table", "fasterize", "RStoolbox", "scales", "purrr", "HURDAT" , "gsw", "R.utils","Matrix")
# "HURDAT",

f.ipak(packages)
# lapply(packages, require, character.only = TRUE)
# rm(f.ipak, packages)
print(paste0("Current Working Directory is ", getwd()))
```
## Load submodule for bio-argo floats
* using newer OneArgo-R
* https://github.com/NOAA-PMEL/OneArgo-R

```{r}
setwd(wd)

# main functions
path<-"r_scripts/submodules/OneArgo-R/"

source(paste0(path, "get_lon_lat_time.R"))
source(paste0(path, "initialize_argo.R"))
source(paste0(path, "load_float_data.R"))
source(paste0(path, "select_profiles.R"))
source(paste0(path, "show_profiles.R"))
source(paste0(path, "show_sections.R"))
source(paste0(path, "show_time_series.R"))
source(paste0(path, "show_trajectories.R"))


# auxilary functions
path = "r_scripts/submodules/OneArgo-R/auxil/"
file_path<-paste0(wd,"/",path)
files<-list.files(file_path, pattern ="\\.R$")

for(i in 1:length(files)){
  source(paste0(path, files[i]))
}

# packages<-c("gsw", "R.utils","Matrix")
# f.ipak(packages)
# 
rm(path, file_path, files)

####   this doesn't work... ####
# perhaps not functions R files breaks it
#file_path<-paste0(wd, "/", path)

#files<-list.files(file_path, pattern ="\\.R")
# for(i in 1:length(files)){
#   source(paste0(path, files[i]), local=F)
# }

```



# functions
adapted, and thinned from ... script
```{r}
### function to create buffer around coastline

f.cl_buffer<-function(function_variables, cl){
  if(is.na(function_variables$land_buffer)==TRUE){
                      function_variables$land_buffer<-100000}
  y<-st_geometry(cl)
  y<-st_union(y, is_coverage = T)
  z<-st_centroid(y)
  land_buffer<-function_variables$land_buffer
  
  lat0<-z[[1]][2]
  lon0<-z[[1]][1]
  center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
  flat<-sf::st_transform(y, center.reproj )
  buffered_land<-sf::st_buffer(flat, dist=land_buffer)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0") 
  return(buffered_land)
}

#### Match up for fro profile and float  inside EP TC zone

f.floats_within_EP<-function(function_variables){
end.date<-(function_variables$h_end_date+function_variables$h.post) %>% as.character(.)

if(is.na(function_variables$argo_sensor)==TRUE) {sensor_selection=NULL }
else {sensor_selection=function_variables$argo_sensor}

# if(is.na(function_variables$ocean)==TRUE) {ob=NULL }
# else {ob=function_variables$ob}

# total_floats<-select_profiles(lon_lim=c(function_variables$bgc.lon_max, function_variables$bgc.lon_min),lat_lim=c(function_variables$bgc.lat_min, function_variables$bgc.lat_max), end_date = end.date, start_date="1990-01-01", outside="none", sensor=sensor_selection, ocean=ob, type='bgc')

# only works for west (-) longitudes *improve here

total_floats<-select_profiles(lon_lim=c(function_variables$bgc.lon_max, function_variables$bgc.lon_min),lat_lim=c(function_variables$bgc.lat_min, function_variables$bgc.lat_max), end_date = end.date, start_date="1990-01-01", outside="none", sensor=sensor_selection, ocean="P", type='bgc')
return(total_floats) 
}

### bgc-argo - to spatial dataframe ###

f.profiles_to_pts<-function(selected_profiles){

profile_points<-vector(mode="list", length(selected_profiles$float_ids))

names(profile_points)<-selected_profiles$float_ids
for(i in 1:length(profile_points)){  
x<-lapply(selected_profiles, function(x) x[i])
y<-get_lon_lat_time((x))
z<-as.data.frame(y)
names(z)<-names(y)
z$profile<-seq(1, length(z[,1]), 1)
selection<-unlist(x$float_profs)
z<-dplyr::filter(z, profile %in% selection )
z$float<-x$float_ids
rm(x,y)
z<-select(z, float, time, profile, lon, lat)

z.pts<-sf::st_as_sf(z, coords = c("lon","lat"), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
 profile_points[[i]]<-z.pts
}


return(profile_points)
}


### helper functions

```


# Data 1
-Hurdat2
-- Hurricane tracks and wind speeds
---Bioargo r 
--Coastline data
## Read in "Best Track Data (HURDAT2)" hurricane data
Using/used 'hurdat package'

```{r}
#download from online. Basin is eastern pacific
#h<-get_hurdat(basin="EP")
#saveRDS(h, "r_objects/hurdat.R")

h<-readRDS("r_objects/hurdat.R")
h$DateTime<-with_tz(h$DateTime, tz="UTC")
```

## natural earth coastlines
source : https://www.naturalearthdata.com/downloads/10m-physical-vectors/10m-coastline/
version: 4.1.0
```{r}
setwd(gis_data)
# save shape files in named directory
coastline<-st_read("./ne_50m_land/ne_50m_land.shp") 
oceans<-st_read("./ne_50m_geography_marine_polys/ne_50m_geography_marine_polys.shp") 

```


# subset h by ocean basins
 * this a brute force method to rmeove a few tracks form a strom(s) that passed from Atlantic over central ameriaca in to the pacific
- removes tc points wioth not lat lon corodantes
- removes and point inthe atlaitc and carribean and gulf etc
- returns filtered non spatial datframe

```{r}
h.pts<-h%>%drop_na(Lon, Lat)%>% sf::st_as_sf(., coords = c("Lon","Lat"), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")

north_atl_basins<-subset(oceans, name %in% c("North Atlantic Ocean", "Caribbean Sea", "Gulf of Mexico", "Sargasso Sea"))
north_atl<-st_union(north_atl_basins)

h.pts<-st_difference(h.pts, st_combine(st_geometry(coastline))) %>% st_difference(., st_combine(st_geometry(north_atl))) 

lon_lat<-do.call(rbind, st_geometry(h.pts))%>%as.data.frame(.) %>% setNames(c("Lon","Lat"))
h<-cbind((st_drop_geometry(h.pts)), lon_lat)
rm(h.pts, north_atl, north_atl_basins, oceans, lon_lat)

```


testing with plots
```{r}

# m.coast <- ggplot()+ geom_sf(data =coastline, size=0.5)+ theme(axis.title.x=element_blank(), axis.title.y=element_blank())+
#   theme_bw()+ theme(text = element_text(size =12)) 
# 
# map1<-m.coast +geom_sf(data=h.pts)
# # map2<-m.coast +geom_sf(data=h.pts)
# 
# map1
# # map2
```


## coastal float subsetting


## Import BioArgo metadata (requires submodule install):
 - uncommnet to get newewts floats
```{r}
#initialize_argo() # downloads meta data for argo
#setwd(robj)
#save(Float, Setting, Sprof, sprof_update, file="init_argo.RData")
setwd(robj)
load("init_argo.RData")
```

# defining spatial bounds and fucntion variables
## Hurdat spatial/temporal bounds
- Hurricane zone defien as max, min of eastern basin Hurdat dtatset
-7 degrere bufer chosen becau of chen et al
-slecested 99% confidnec interval for altiduanl range to excluse northern outliers
-used 1/2 degre resoultion
```{r}
buffer=7
#buffer is in degrees
#west<-min(na.omit(h$Lon))-buffer
Lat.99<-quantile((na.omit(h$Lat)),probs=c(0.001,0.99)) # remove anonymous outliers otherwise hurricane zone is 70 N

west_argo=-180
north_tc<-(round_any(Lat.99[[2]], 0.5, f= round))
south_tc<-(round_any(Lat.99[[1]], 0.5, f= round))

# TC that crossed over from atlatinc inflates eatssern boundary
east_tc<-round_any(max(na.omit(h$Lon[h$Lon < 0])), 0.5, f = round)
# east_tc<--80

#dont need TC Buffers
# west_tc<-west_argo+buffer
west_tc<-west_argo


north_argo<-north_tc+buffer 
south_argo<-south_tc-buffer
east_argo<-east_tc+buffer

# north<-max(na.omit(h$Lat))+buffer
# south<-min(na.omit(h$Lat))-buffer

print(min(na.omit(h$DateTime)))
print(max(na.omit(h$DateTime)))
print(c(north_argo, south_argo, west_argo, east_argo))

```

Add variables here

100km
200 km
500 km 

## function_variables (INCLUDES DYNAMIC VARIABLES based on Hurdat (h)):
Appending 'function_variables' with dynamic variables from hurdat 'h' data set
* originally from script "
* define here as opposed to within function or sub blocks
+ add hurdat coordinates as bbox feature

Note importance of "function_variables<-vector(mode="list")"

```{r}
function_variables<-vector(mode="list") # for storing all function variables that may be dynamic or other wise

### user defined: ####
# prior and post for time frame for argo profiles that fall within spatial selection window

#### spatial temporal secltion #####
# time
function_variables$h.prior<-30
function_variables$h.post<-45
## end date of hurricane database 
function_variables$h_end_date<- max(na.omit(h$DateTime)) %>% as.Date(.)

# space
function_variables$ocean="P"
#ocean is Pacific

function_variables$bgc.lon_max<-west_argo 
function_variables$bgc.lat_max<-north_argo
function_variables$bgc.lat_min<-south_argo
function_variables$bgc.lon_min<-east_argo

# need to set this below for stititcs
# function_variables$bgc.lon_min <--80


function_variables$tc.lon_max<-west_tc 
function_variables$tc.lat_max<-north_tc
function_variables$tc.lat_min<-south_tc
function_variables$tc.lon_min<-east_tc


# radius around TS in m
function_variables$tc.radi_1<-100000
function_variables$tc.radi_2<-200000
function_variables$tc.radi_3<-500000
function_variables$land_buffer<-200000

#### bgc-argo selection parameters ####
function_variables$year_begin<-1990

function_variables$argo_sensor<-NA 
#c("DOXY") #pick a single argo sensor, "TEMP", etc.)

function_variables$selection<-paste0("Lat (", function_variables$bgc.lat_min, ", ", function_variables$bgc.lat_max, ") Lon 
(", function_variables$bgc.lon_min, ", ", function_variables$bgc.lon_max,  ")")

```


# Float slection  and satistics
## step one square slection
This will now download all the NC Files!

### run selection
```{r}
#slects profiles and floats within the  TC slection plus buffer does not remove coast

# 
function_variables$argo_sensor<-NA
ep_total_floats<-f.floats_within_EP(function_variables)

function_variables$argo_sensor<-"DOXY"
ep_doxy_floats<-f.floats_within_EP(function_variables)

```
### save/load ep_doxy floats
```{r}
setwd(wd)
setwd(robj)
# saveRDS(ep_doxy_floats, "ep_doxy_floats.rds")
ep_doxy_floats<-readRDS("ep_doxy_floats.rds")
```


#### summarry statitics
```{r}
print(length(unique((na.omit(ep_total_floats$float_ids)))))
print(sum(lengths(ep_total_floats$float_profs)))

print(length(unique((na.omit(ep_doxy_floats$float_ids)))))
print(sum(lengths(ep_doxy_floats$float_profs)))

```


## profiles to points

```{r}
print("this takes a long time")
profile_points<-f.profiles_to_pts(selected_profiles = ep_doxy_floats)

```

### save/load profile_points
```{r}
setwd(wd)
setwd(robj)
# saveRDS(profile_points, "profile_points.rds")
profile_points<-readRDS("profile_points.rds")
```

### create data frame from list

```{r}
df.profile_points <- ldply(profile_points, data.frame)%>% select(., -.id)
sf.profile_points<-st_as_sf(df.profile_points)


```


# buffered land & cl

```{r}

## land buffer
cl<-st_crop(coastline, xmin=function_variables$bgc.lon_min, ymin=function_variables$bgc.lat_min, xmax=function_variables$bgc.lon_max, ymax=function_variables$bgc.lat_max)
#rm(coastline)


buffered_land<-f.cl_buffer(function_variables, cl)
#rm(cl)
```





## some plots

```{r}
m.coast <- ggplot()+ geom_sf(data =cl, size=0.5)+ theme(axis.title.x=element_blank(), axis.title.y=element_blank())+
  theme_bw()+ theme(text = element_text(size =12)) 

# m.buffered_coast<-ggplot()+ geom_sf(data =buffered_land, size=0.5)+ theme(axis.title.x=element_blank(), axis.title.y=element_blank())+
#   theme_bw()+ theme(text = element_text(size =12))

#m.buffered_coast
m.map<-m.coast+geom_sf(data=sf.profile_points)
m.map
#ggplot(data = test) +geom_sf()

```

# TC point to lines

 - create  sf point first or can I skip/
 - crop using ocena hspae file form natural earth
 -Turn bleow into a function (don't prmeaturaly optimize...)

## points 
```{r}
h.pts<-select(h, Key, Name, DateTime, Status, Lat, Lon, Wind, Pressure)%>% na.omit(.) %>% sf::st_as_sf(., coords = c("Lon","Lat"), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")

#remove TXS outside area of interest
h.pts<-sf::st_crop(h.pts, c(xmin=function_variables$tc.lon_min, ymin=function_variables$tc.lat_min, xmax=function_variables$tc.lon_max, ymax=function_variables$tc.lat_max)) #subset by user defined 

# m.map<-m.coast+geom_sf(data=h.pts)+geom_sf(data= sf.profile_points, col="blue")
# m.map
#st_bbox(h.pts)

```

##   multi points and tracks

(1) creates a multipoint  per TC key, with start end tiem bounds per each TC line string
(2) "" but crea a multiline

```{r}
x<-h.pts%>% st_drop_geometry(.) %>% select(., Key, DateTime) %>% group_by(Key) %>% summarize(start_dt= min(DateTime), end_dt = max(DateTime))

h.multipoints<-as_data_frame(unique(h.pts$Key))
names(h.multipoints)<-("Key")
st_geometry(h.multipoints)<-(split(h.pts, h.pts$Key) %>% Map(st_combine,. )%>%do.call(c,.))

h.multipoints<-left_join(x, h.multipoints) %>%st_as_sf(.)
h.tracks<-h.multipoints

#theres probally a better way...thena for loop
for(i in 1:length(h.tracks$Key)){
h.tracks$geometry[i]<-st_cast(h.tracks$geometry[i], to= "LINESTRING")
}
h.tracks<-st_as_sf(h.tracks)

rm(x)

```

## match flots to tracks temporally
 This benefit from beinag a function
 variable on buffer
```{r}
f.in_between_time<-function(h.tracks, function_variables, df.profile_points){

x<-select(h.tracks, -geometry) %>% as.data.frame(.)
y<-df.profile_points
y$time<-date(y$time)
pre<-function_variables$h.prior
post<-function_variables$h.post

x$start_dt <-x$start_dt %>% as_datetime(.) %>%round_date(., "day") %>%as_date(.) -pre
x$end_dt<-x$end_dt %>% as_datetime(.) %>%round_date(., "day") %>%as_date(.) + pre  

z<-vector(mode="list", length(x$Key))
names(z)<-x$Key



for(i in 1:length(z)){

z[[i]]<-filter(y, time >= x[i,]$start_dt & time <=x[i,]$end_dt)
}


z<-z[unlist(lapply(z, nrow) != 0)]


return(z)
}

z<-f.in_between_time(h.tracks, function_variables, df.profile_points)

```



## Float TC  line distance - will need to double check this correct
```{r}

for(i in 1:length(z)){
x<-z[[i]]
x.key<-names(z)[i]
y<-filter(h.tracks, Key == x.key)
x$distance_m<-st_distance(y$geometry,x$geometry) %>% as.vector(.)
z[[i]]<-x}

```

##
```{r}

f.distance_select<-function  


```

