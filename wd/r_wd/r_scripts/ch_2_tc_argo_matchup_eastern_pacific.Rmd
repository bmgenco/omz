---
title: "ch2_TC_argo_match up"
output: html_document
date: '2023-09-12'
---

# Setup

## Directories and defaults

Ideally uses proj file for relative directories see: <https://yihui.org/knitr/options/>

Directory structure used in this analysis:

~/omz/wd -- /output -- /data -- /figures -- /r_wd

~/omz/wd/r_wd -- /Index -- /Profiles -- /r_objects -- /r_scripts

```{r setup}
rm(list=ls())

r_scriptwd<-getwd()
wd<-substring(r_scriptwd,1,nchar(r_scriptwd) -10) # hardcoding replace here
knitr::opts_knit$set(root.dir = wd)

# relative directories
robj<-"r_objects"
fig<-"../../figures"
gis_data<-"../../data/gis_data"
output<-"../../output"
data_d<-"../../data"

# ocean_color<-"../../data/ocean_color_bud"
# bathy_d<-"../../data/bathy" # edit this

knitr::opts_chunk$set(echo =FALSE)
#knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

## Packages

Installed custom hurdat package using r markdown menu \* download tar from archive as no longer maintained on cran repository \* <https://cran.r-project.org/src/contrib/Archive/HURDAT/> + include as git submodule instead

```{r}
wd<-getwd()
f.ipak <- function(pkg){
  # loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
  # will install  packages listed , and their dependencies, if needed.
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg))
    install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
  sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}
packages<-c("plyr","sp", "rgdal",  "rgeos", "raster", "readr", "tidyverse", "lubridate",  "ggthemes",  "sf", "cmocean", "ncdf4", "RNetCDF",  "plot3D", "tidync", "devtools", "stars", "ncmeta", "maps", "oce", "data.table", "fasterize", "RStoolbox", "scales", "purrr", "HURDAT" , "gsw", "R.utils","Matrix")
# "HURDAT",
f.ipak(packages)
# lapply(packages, require, character.only = TRUE)
# rm(f.ipak, packages)
print(paste0("Current Working Directory is ", getwd()))
```

## Load submodule for bio-argo floats

-   using newer OneArgo-R
-   <https://github.com/NOAA-PMEL/OneArgo-R>

```{r}
# setwd(wd)

# main functions
path<-"r_scripts/submodules/OneArgo-R/"

source(paste0(path, "get_lon_lat_time.R"))
source(paste0(path, "initialize_argo.R"))
source(paste0(path, "load_float_data.R"))
source(paste0(path, "select_profiles.R"))
source(paste0(path, "show_profiles.R"))
source(paste0(path, "show_sections.R"))
source(paste0(path, "show_time_series.R"))
source(paste0(path, "show_trajectories.R"))


# auxilary functions
path = "r_scripts/submodules/OneArgo-R/auxil/"
file_path<-paste0(wd,"/",path)
files<-list.files(file_path, pattern ="\\.R$")

for(i in 1:length(files)){
  source(paste0(path, files[i]))
}

# packages<-c("gsw", "R.utils","Matrix")
# f.ipak(packages)
# 
rm(path, file_path, files)

####   this doesn't work... ####
# perhaps not functions R files breaks it
#file_path<-paste0(wd, "/", path)

#files<-list.files(file_path, pattern ="\\.R")
# for(i in 1:length(files)){
#   source(paste0(path, files[i]), local=F)
# }

```

# functions

adapted, and thinned from ... script "Hurricane_insitu_matchup_v2.Rmd"

```{r}
### function to create buffer around coastline

f.cl_buffer<-function(function_variables, cl){
  if(is.na(function_variables$land_buffer)==TRUE){
                      function_variables$land_buffer<-100000}
  y<-st_geometry(cl)
  y<-st_union(y, is_coverage = T)
  z<-st_centroid(y)
  land_buffer<-function_variables$land_buffer
  
  lat0<-z[[1]][2]
  lon0<-z[[1]][1]
  center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
  flat<-sf::st_transform(y, center.reproj )
  buffered_land<-sf::st_buffer(flat, dist=land_buffer)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0") 
  return(buffered_land)
}

#### Match up for for profile and float  inside EP TC zone

f.floats_within_EP<-function(function_variables){
end.date<-(function_variables$h_end_date+function_variables$h.post) %>% as.character(.)

if(is.na(function_variables$argo_sensor)==TRUE) {sensor_selection=NULL }
else {sensor_selection=function_variables$argo_sensor}

# if(is.na(function_variables$ocean)==TRUE) {ob=NULL }
# else {ob=function_variables$ob}

# total_floats<-select_profiles(lon_lim=c(function_variables$bgc.lon_max, function_variables$bgc.lon_min),lat_lim=c(function_variables$bgc.lat_min, function_variables$bgc.lat_max), end_date = end.date, start_date="1990-01-01", outside="none", sensor=sensor_selection, ocean=ob, type='bgc')

# only works for west (-) longitudes *improve here

total_floats<-select_profiles(lon_lim=c(function_variables$bgc.lon_max, function_variables$bgc.lon_min),lat_lim=c(function_variables$bgc.lat_min, function_variables$bgc.lat_max), end_date = end.date, start_date="1990-01-01", outside="none", sensor=sensor_selection, ocean="P", type='bgc')
return(total_floats) 
}

### bgc-argo - to spatial dataframe ###
f.profiles_to_pts<-function(selected_profiles){

profile_points<-vector(mode="list", length(selected_profiles$float_ids))

names(profile_points)<-selected_profiles$float_ids
for(i in 1:length(profile_points)){  
x<-lapply(selected_profiles, function(x) x[i])
y<-get_lon_lat_time((x))
z<-as.data.frame(y)
names(z)<-names(y)
z$profile<-seq(1, length(z[,1]), 1)
selection<-unlist(x$float_profs)
z<-dplyr::filter(z, profile %in% selection )
z$float<-x$float_ids
rm(x,y)
z<-select(z, float, time, profile, lon, lat)

z.pts<-sf::st_as_sf(z, coords = c("lon","lat"), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
 profile_points[[i]]<-z.pts
}


return(profile_points)
}

### select floats by time and TC ###
f.in_between_time<-function(h.tracks, function_variables, df.profile_points){
x<-dplyr::select(h.tracks, -geometry) %>% as.data.frame(.)
y<-df.profile_points
y$time<-date(y$time)
pre<-function_variables$h.prior
post<-function_variables$h.post

x$start_dt <-x$start_dt %>% as_datetime(.) %>%round_date(., "day") %>%as_date(.) -pre
x$end_dt<-x$end_dt %>% as_datetime(.) %>%round_date(., "day") %>%as_date(.) + pre  

z<-vector(mode="list", length(x$Key))
names(z)<-x$Key

for(i in 1:length(z)){
z[[i]]<-filter(y, time >= x[i,]$start_dt & time <=x[i,]$end_dt)
}
z<-z[unlist(lapply(z, nrow) != 0)]
return(z)
}

### select floats within desired radi
f.radi_select<-function(x, tc_radi){
x<-filter(x, distance_m <= tc_radi)
return(x)
}

### select Storm matched floats radi object wit storms of desries desired strength

f.storm_strength_filter<-function(x, h.storm_list, storm_level=NULL){
  
  all<-c("TS", "HU", "TD", "LO", "ET", "EX", "DB","SD", "SS", "PT", "ST", "TY", "WV", NA)
  tc<-c("TS", "HU", "TD") 
  hu<-("HU")

if(is.null(storm_level)) {
    tc_selection<-all
  }  else if (storm_level == "all") {
  tc_selection<-all
}  else if (storm_level == "tc") {
  tc_selection<-tc
} else if  (storm_level == "hu") {
  tc_selection<-hu
}    
    
f.selection<-function(y, tc_selection){y<-filter(y, Status %in% tc_selection)
  return(y)}
f.intersect<-function(x, selection){
  x<-x[intersect(names(x), selection)]
    return(x)
  }


  
  h.storm_list<-lapply(h.storm_list, f.selection, tc_selection=tc_selection)
  h.storm_list<-f.rm_empty(h.storm_list) %>%names(.)

  
    x<-f.intersect(x, selection=h.storm_list)
return(x)
}

### helper functions

# remove empty list items
f.rm_empty<-function(x){x<-x[unlist(lapply(x, nrow) != 0)]
return(x)}
```

# Data 1

-Hurdat2 -- Hurricane tracks and wind speeds ---Bioargo r --Coastline data \## Read in "Best Track Data (HURDAT2)" hurricane data Using/used 'hurdat package'

```{r}
#download from online. Basin is eastern pacific
#h<-get_hurdat(basin="EP")
#saveRDS(h, "r_objects/hurdat.R")

h<-readRDS("r_objects/hurdat.R")
h$DateTime<-with_tz(h$DateTime, tz="UTC")
```

## natural earth coastlines

source : <https://www.naturalearthdata.com/downloads/10m-physical-vectors/10m-coastline/> version: 4.1.0

```{r}
setwd(gis_data)
# save shape files in named directory
coastline<-st_read("./ne_50m_land/ne_50m_land.shp") 
oceans<-st_read("./ne_50m_geography_marine_polys/ne_50m_geography_marine_polys.shp") 
```

# subset h by ocean basins

-   this a brute force method to rmeove a few tracks form a strom(s) that passed from Atlantic over central ameriaca in to the pacific
-   removes tc points wioth not lat lon corodantes
-   removes and point inthe atlaitc and carribean and gulf etc
-   returns filtered non spatial datframe

```{r}
h.pts<-h%>%drop_na(Lon, Lat)%>% sf::st_as_sf(., coords = c("Lon","Lat"), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")

north_atl_basins<-subset(oceans, name %in% c("North Atlantic Ocean", "Caribbean Sea", "Gulf of Mexico", "Sargasso Sea"))
north_atl<-st_union(north_atl_basins)

h.pts<-st_difference(h.pts, st_combine(st_geometry(coastline))) %>% st_difference(., st_combine(st_geometry(north_atl))) 

lon_lat<-do.call(rbind, st_geometry(h.pts))%>%as.data.frame(.) %>% setNames(c("Lon","Lat"))
h<-cbind((st_drop_geometry(h.pts)), lon_lat)

rm(h.pts, north_atl, north_atl_basins, oceans, lon_lat)
```

testing with plots

```{r}

# m.coast <- ggplot()+ geom_sf(data =coastline, size=0.5)+ theme(axis.title.x=element_blank(), axis.title.y=element_blank())+
#   theme_bw()+ theme(text = element_text(size =12)) 

# map1<-m.coast +geom_sf(data=h.pts)
# # map2<-m.coast +geom_sf(data=h.pts)
#
# map1
# # map2
```

## coastal float subsetting

## Import BioArgo metadata (requires submodule install):

-   uncomment to get newest floats

```{r}
# initialize_argo() # downloads meta data for argo
# #setwd(robj)
# # save(Float, Setting, Sprof, sprof_update, file="r_objects/init_argo.RData")
# save(Float, Setting, Sprof, file="r_objects/init_argo.RData")

# load("r_objects/init_argo.RData")
```

# defining spatial bounds and fucntion variables

## Hurdat spatial/temporal bounds

-   Hurricane zone define as max, min of eastern basin Hurdat datset -7 degree buffer chosen because of chen et al. -selected 99% confidence interval for latitudinal range to exclude northern outliers -used 1/2 degree resolution

```{r}
buffer=7
#buffer is in degrees
#west<-min(na.omit(h$Lon))-buffer
Lat.99<-quantile((na.omit(h$Lat)),probs=c(0.001,0.99)) # remove anonymous outliers otherwise hurricane zone is 70 N

west_argo=-180
north_tc<-(round_any(Lat.99[[2]], 0.5, f= round))
south_tc<-(round_any(Lat.99[[1]], 0.5, f= round))

# TC that crossed over from atlatinc inflates eatssern boundary
east_tc<-round_any(max(na.omit(h$Lon[h$Lon < 0])), 0.5, f = round)
# east_tc<--80

#dont need TC Buffers
# west_tc<-west_argo+buffer
west_tc<-west_argo

north_argo<-north_tc+buffer 
south_argo<-south_tc-buffer
east_argo<-east_tc+buffer #this will cpature profilesin atlantic, but argo slection parmater negates this issue

# north<-max(na.omit(h$Lat))+buffer
# south<-min(na.omit(h$Lat))-buffer

print(min(na.omit(h$DateTime)))
print(max(na.omit(h$DateTime)))
print(c(north_argo, south_argo, west_argo, east_argo))

```

Add variables here

100km 200 km 500 km

# function_variables (INCLUDES DYNAMIC VARIABLES based on Hurdat (h)):

Appending 'function_variables' with dynamic variables from hurdat 'h' data set \* originally from script "Hurricane_insitu_matchup_v2.Rmd" \* define here as opposed to within function or sub blocks + add hurdat coordinates as bbox feature

Note importance of "function_variables\<-vector(mode="list")"

```{r}
function_variables<-vector(mode="list") # for storing all function variables that may be dynamic or other wise

### user defined: ####
# prior and post for time frame for argo profiles that fall within spatial selection window

#### spatial temporal secltion #####
# time
function_variables$h.prior<-30
function_variables$h.post<-45
## end date of hurricane database 
function_variables$h_end_date<- max(na.omit(h$DateTime)) %>% as.Date(.)

# space
function_variables$ocean="P"
#ocean is Pacific


# in futre change lon_min variable names
function_variables$bgc.lon_max<-west_argo 
function_variables$bgc.lat_max<-north_argo
function_variables$bgc.lat_min<-south_argo
function_variables$bgc.lon_min<-east_argo

# need to set this below for stititcs
# function_variables$bgc.lon_min <--80

function_variables$tc.lon_max<-west_tc 
function_variables$tc.lat_max<-north_tc
function_variables$tc.lat_min<-south_tc
function_variables$tc.lon_min<-east_tc

# radius around TS in m
function_variables$tc.radi_1<-100000
function_variables$tc.radi_2<-200000
function_variables$tc.radi_3<-500000
function_variables$land_buffer<-200000

#### bgc-argo selection parameters ####
function_variables$year_begin<-1990

function_variables$argo_sensor<-NA 
#c("DOXY") #pick a single argo sensor, "TEMP", etc.)

function_variables$selection<-paste0("Lat (", function_variables$bgc.lat_min, ", ", function_variables$bgc.lat_max, ") Lon 
(", function_variables$bgc.lon_min, ", ", function_variables$bgc.lon_max,  ")")

rm(buffer,east_argo, east_tc, west_argo, west_tc, north_argo, north_tc, south_argo, south_tc, Lat.99)
```

# Float selection and satistics

## step one square slection

This will now download all the NC Files!

### run selection

```{r}
#select profiles and floats within the  TC selection plus buffer does not remove coast

function_variables$argo_sensor<-NA
ep_total_floats<-f.floats_within_EP(function_variables)

function_variables$argo_sensor<-"DOXY"
ep_doxy_floats<-f.floats_within_EP(function_variables)

```

### save/load ep_doxy floats

```{r}
# setwd(wd)
# setwd(robj)
saveRDS(ep_doxy_floats, "r_objects/ep_doxy_floats.rds")
# ep_doxy_floats<-readRDS("r_objects/ep_doxy_floats.rds")
```

## summarry statitics

```{r}
print(length(unique((na.omit(ep_total_floats$float_ids)))))
print(sum(lengths(ep_total_floats$float_profs)))

print(length(unique((na.omit(ep_doxy_floats$float_ids)))))
print(sum(lengths(ep_doxy_floats$float_profs)))
# #
```

# profiles to points

This will now re-download all the NC Files! plus time it takes to search through nc files

```{r}
print("this takes a long time")
profile_points<-f.profiles_to_pts(selected_profiles = ep_doxy_floats)
```

## save/load profile_points

```{r}
# setwd(wd)
# setwd(robj)
# saveRDS(profile_points, "r_objects/profile_points.rds")
profile_points<-readRDS("r_objects/profile_points.rds")
```

### create data frame from list

```{r}
df.profile_points <- ldply(profile_points, data.frame)%>% dplyr::select(., -.id)
sf.profile_points<-st_as_sf(df.profile_points) # only needed for plotting
```

# buffered land & cl

```{r}
# land buffer
cl<-st_crop(coastline, xmin=function_variables$bgc.lon_min, ymin=function_variables$bgc.lat_min, xmax=function_variables$bgc.lon_max, ymax=function_variables$bgc.lat_max)
# #rm(coastline)
# #
# buffered_land<-f.cl_buffer(function_variables, cl)
#rm(cl)
```

## some plots

```{r}
m.coast <- ggplot()+ geom_sf(data =cl, size=0.5)+ theme(axis.title.x=element_blank(), axis.title.y=element_blank())+
  theme_bw()+ theme(text = element_text(size =12))
# 
# # m.buffered_coast<-ggplot()+ geom_sf(data =buffered_land, size=0.5)+ theme(axis.title.x=element_blank(), axis.title.y=element_blank())+
# #   theme_bw()+ theme(text = element_text(size =12))
# 
# #m.buffered_coast
m.map<-m.coast+geom_sf(data=sf.profile_points)
m.map
#ggplot(data = test) +geom_sf()

```

# TC point to lines

-   create sf point first or can I skip..
-   crop using ocean shape file from natural earth -Turn beloww into a function (don't prematurely optimize...)

## points

```{r}
h.pts<-dplyr::select(h, Key, Name, DateTime, Status, Lat, Lon, Wind, Pressure)%>% na.omit(.) %>% sf::st_as_sf(., coords = c("Lon","Lat"), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")

#remove TCs outside area of interest
h.pts<-sf::st_crop(h.pts, c(xmin=function_variables$tc.lon_min, ymin=function_variables$tc.lat_min, xmax=function_variables$tc.lon_max, ymax=function_variables$tc.lat_max)) #subset by user defined 

# m.map<-m.coast+geom_sf(data=h.pts)+geom_sf(data= sf.profile_points, col="blue")
# m.map
#st_bbox(h.pts)
```

## multi points and tracks

(1) creates a multipoint per TC key, with start end time bounds per each TC line string
(2) "" but create a track - line geomtery

TO do recreta multipoint object as well
```{r}

x<-h.pts%>% st_drop_geometry(.) %>% dplyr::select(., Key, DateTime)%>% group_by(Key) %>% dplyr::summarize(start_dt= min(DateTime), end_dt = max(DateTime))


w<-(split(h.pts, h.pts$Key))
f.make_multipoint<-function(x){
  x$multipoints<-st_combine(x$geometry)
  st_geometry(x)<-NULL
  
  x<-select(x, Key, multipoints)
  x$geometry<-x$multipoints
  x<-select(x, Key, geometry)
  x<-x[1,]
  st_geometry(x)<-x$geometry
  return(x)
}
w<-lapply(w, f.make_multipoint)
w<-bind_rows(w, .id = "column_label")
w<-select(w, -column_label)



h.tracks<-dplyr::left_join(x, w) %>%st_as_sf(.)
h.tracks$tracks<-st_cast(h.tracks$geometry, "LINESTRING")

# needed to match function
h.tracks<-st_drop_geometry(h.tracks)
names(h.tracks)[which(names(h.tracks)=="tracks")]<-'geometry'
h.tracks<-h.tracks%>%st_set_geometry(., .$geometry)



```


#### testing

```{r}
# 
# # plot(x$geometry)
# # 
# # test<-filter(h, Name =="GILMA")
# x<-filter(h.tracks, Key=="EP072012")
# 
# 
# y<-filter(h.pts, Key=="EP072012")
# 
# p<-m.coast+geom_sf(data=x)+geom_sf(data=y)
# p
```




# matching floats

## match floats to tracks temporally and add distance

variable on time window

```{r}
z<-f.in_between_time(h.tracks, function_variables, df.profile_points)

## Float TC  line distance - will need to double check this correct
for(i in 1:length(z)){
x<-z[[i]]
x.key<-names(z)[i]
y<-filter(h.tracks, Key == x.key)
x$distance_m<-st_distance(y$geometry,x$geometry) %>% as.vector(.)
z[[i]]<-x
rm(x,x.key,y)
}

```

## add neasret point to z


## select floats by buffer

variable on time window -if change in set of radi, then will need to write function to make variable names dynamic

```{r}

all_storms_500km<-lapply(z, f.radi_select, tc_radi=function_variables$tc.radi_3)
all_storms_500km<-f.rm_empty(all_storms_500km)

km_100<-lapply(z, f.radi_select, tc_radi=function_variables$tc.radi_1)
km_100<-f.rm_empty(km_100)
km_200<-lapply(z, f.radi_select, tc_radi=function_variables$tc.radi_2)
km_200<-f.rm_empty(km_200)
km_500<-lapply(z, f.radi_select, tc_radi=function_variables$tc.radi_3)
km_500<-f.rm_empty(km_500)

# all_storms_500km

# create list of above lists fo future selection 

rm(z)
```

# filtering by storm strength



```{r}
storm_list<-names(all_storms_500km)
rm(all_storms_500km)
h.storm_list<-filter(h, Key %in% storm_list) %>% dplyr::select(., Key, Status)%>% split(., .$Key) 

# all_100<-f.storm_strength_filter(km_100,  h.storm_list, storm_level = 'all')
hu_100<-f.storm_strength_filter(km_100,  h.storm_list, storm_level = 'hu')
tc_100<-f.storm_strength_filter(km_100,  h.storm_list, storm_level = 'tc')

# all_200<-f.storm_strength_filter(km_200,  h.storm_list, storm_level = 'all')
hu_200<-f.storm_strength_filter(km_200,  h.storm_list, storm_level = 'hu')
tc_200<-f.storm_strength_filter(km_200,  h.storm_list, storm_level = 'tc')

# all_500<-f.storm_strength_filter(km_500,  h.storm_list, storm_level = 'all')
hu_500<-f.storm_strength_filter(km_500,  h.storm_list, storm_level = 'hu')
tc_500<-f.storm_strength_filter(km_500,  h.storm_list, storm_level = 'tc')

print('100km :')
# length(all_100)
length(tc_100)
length(hu_100)

print('200km :')
# length(all_200)
length(tc_200)
length(hu_200)

print('500km :')
# length(all_500)
length(tc_500)
length(hu_500)

rm(km_100, km_200, km_500, h.storm_list)
```

## statistics TCs, float and profiles
```{r}
f.summary<-function(x){
stats<-vector(mode="list")  
stats$tcs<-length(x)

f.length<-function(x){x<-length(x$profile)}
stats$total_profiles<-(lapply(x, f.length)) %>% unname(.) %>% unlist(.) %>% sum(.)
f.floats<-function(x){x<-unique(x$float)}
stats$floats<-lapply(x, f.floats)%>% unname(.) %>% unlist(.) %>% unique(.) %>% length(.)

print(stats)
}

print("100 km tc stats:")
f.summary(tc_100)
print("200 km tc stats:")
f.summary(tc_200)
print("500 km tc stats:")
f.summary(tc_500)

```

## statitics hurricanes

```{r}
#  floats, profiles, & tcs per buffer selection

print("100 km hu stats:")
f.summary(hu_100)
print("200 km hu stats:")
f.summary(hu_200)
print("500 km hu stats:")
f.summary(hu_500)

```





## cat 4/5 hurricnes

```{r}
storm_list<-names(hu_500)
h.storm_list<-filter(h, Key %in% storm_list)%>% split(., .$Key)
rm(storm_list)

f.strong_storms<-function(x){x<-filter(x, Wind >=113)%>%dplyr::select(., Key, Status)
return(x)}
h.storm_list<-lapply(h.storm_list, f.strong_storms)
h.storm_list<-f.rm_empty(h.storm_list)

strong_100<-f.storm_strength_filter(tc_100,  h.storm_list, storm_level = 'all')
strong_200<-f.storm_strength_filter(tc_200,  h.storm_list, storm_level = 'all')
strong_500<-f.storm_strength_filter(tc_500,  h.storm_list, storm_level = 'all')
rm(h.storm_list)

print("strong 100 km hu stats:")
f.summary(strong_100)
print("strong 200 km hu stats:")
f.summary(strong_200)
print("strong 500 km hu stats:")
f.summary(strong_500)
```
# New _ point of interection
see: https://gis.stackexchange.com/questions/243994/how-to-calculate-distance-from-point-to-linestring-in-r-using-sf-library-and-g

## load data
```{r}
data<-readRDS("r_objects/ch2_seq_1_data.R")

function_variables<-data$function_variables
# hurdat objects
h<-data$selected_zone_hurdat$h
h.pts<-data$selected_zone_hurdat$h.pts
h.tracks<-data$selected_zone_hurdat$h.tracks

# match_up

list.100<-data$tc_search_radi_profiles$km_100
list.200<-data$tc_search_radi_profiles$km_200
list.500<-data$tc_search_radi_profiles$km_500

# rm(data)
```
## point of it

```{r}
x<-list.500



```

## dumy
```{r}


lon<-c(0,10)
lat<-c(0,0)
l<-cbind(lon,lat) %>%as.data.frame(.)
l <-st_as_sf(l, coords = c("lon","lat"), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")


l$geometry<-st_combine(l$geometry)
l<-l[1,]
l<-st_cast(l, "LINESTRING")

lon<-5
lat<-1
p<-cbind(lon,lat) %>%as.data.frame(.)
p<-st_as_sf(p, coords = c("lon","lat"), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")%>%st_as_sf()

f1<-ggplot()+geom_sf(data=l)+geom_sf(data=p)



i<-st_nearest_points(p,l)%>% st_cast(., "POINT") %>% st_sf(.)
st_geometry(i) <- "geometry"
i$dis<-st_distance(i,l)
i<-i[order(i$dis),] %>% .[1,] %>% .$geometry



f2<-f1+geom_sf(data=i, col ="blue")
```
https://github.com/r-spatial/sf/issues/669






# tiem of overpass


# save list of objects for next script in seq of analysis

```{r}
y<-vector(mode='list')
y$read_me<-(" this is a list created from first script in ch2 seq , 'ch_2_tc_argo_matchup_eastern_pacific.Rmd'created 2023-09-25 -19:00. $function_variablebles give parameters for selected objects. debugging track issue ")
y$function_variables<-function_variables

x<-vector(mode='list')
x$km_100<-list(tc_100, hu_100, strong_100)
names(x$km_100)<-c('tc', 'hu', 'strong_hu')

x$km_200<-list(tc_200, hu_200, strong_200)
names(x$km_200)<-c('tc', 'hu', 'strong_hu')

x$km_500<-list(tc_500, hu_500, strong_500)
names(x$km_500)<-c('tc', 'hu', 'strong_hu')
y$tc_search_radi_profiles<-x
rm(x)

z<-vector(mode='list')
z$h<-h
z$h.pts<-h.pts
# z$h.multipoints<-h.multipoints
z$h.tracks<-h.tracks
y$selected_zone_hurdat<-z
rm(z)

w<-vector(mode='list')
w$df.profile_points<-df.profile_points
# w$ep_doxy_floats<-ep_doxy_floats
y$selected_zone_float_metadata<-w

rm(w)


saveRDS(y, "r_objects/ch2_seq_1_data.R")



```

## some simple plots

# match hurrcane datbase with argo

(1) \<-500 km list

-   lsit items per Key -- sub lists: --- profiles/distancr --- hurrican datbase --- h.pts ---h.multiple point --h.tracks
