---
title: "ch2_TC_argo_match up"
output: html_document
date: '2023-09-12'
---
 
# Setup
## Directories and defaults

Ideally yous proj file for relative directories
see: https://yihui.org/knitr/options/

Directory structure  used in this analysis:

~/omz/wd
-- /output
-- /data
-- /figures
-- /r_wd

~/omz/wd/r_wd
-- /Index
-- /Profiles
-- /r_objects
-- /r_scripts


```{r setup}
rm(list=ls())

r_scriptwd<-getwd()
wd<-substring(r_scriptwd,1,nchar(r_scriptwd) -10) # hardcoding replace here
knitr::opts_knit$set(root.dir = wd)

# relative directories
robj<-"r_objects"
fig<-"../../figures"
gis_data<-"../../data/gis_data"
output<-"../../output"
data_d<-"../../data"
# ocean_color<-"../../data/ocean_color_bud"
# bathy_d<-"../../data/bathy" # edit this

knitr::opts_chunk$set(echo =FALSE)
#knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

## Packages

Installed custom hurdat package using r markdown menu
* download  tar from archive as no longer maintained on cran repository
* https://cran.r-project.org/src/contrib/Archive/HURDAT/
+ include as git submodule instead

```{r}
wd<-getwd()

f.ipak <- function(pkg){
  # loads packages, quietly, given by a vector of package names e.g., pkg<-c("ggplot", "tidyverse")
  # will install  packages listed , and their dependencies, if needed.
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg))
    install.packages(new.pkg, dependencies = TRUE, quiet=T, verbose = F)
  sapply(pkg, require, character.only = TRUE, quietly = FALSE, warn.conflicts=F)
}

packages<-c("plyr","sp", "rgdal",  "rgeos", "raster", "readr", "tidyverse", "lubridate",  "ggthemes",  "sf", "cmocean", "ncdf4", "RNetCDF",  "plot3D", "tidync", "devtools", "stars", "ncmeta", "maps", "oce", "data.table", "fasterize", "RStoolbox", "scales", "purrr", "HURDAT" )
# "HURDAT",

f.ipak(packages)
# lapply(packages, require, character.only = TRUE)
# rm(f.ipak, packages)
print(paste0("Current Working Directory is ", getwd()))
```
## Load submodule for bio-argo floats

```{r argo submodule}
setwd(wd)
path_code = "r_scripts/submodules/BGC-ARGO_R_WORKSHOP/"

source(paste0(path_code, "initialize_argo.R"))
source(paste0(path_code, "try_download.R"))
source(paste0(path_code, "do_download.R"))
source(paste0(path_code, "download_float.R"))
source(paste0(path_code, "download_multi_floats.R"))
source(paste0(path_code, "check_dir.R"))
source(paste0(path_code, "get_var_name_units.R"))
source(paste0(path_code, "select_profiles.R"))
source(paste0(path_code, "load_float_data.R"))
source(paste0(path_code, "plot_trajectories.R"))
source(paste0(path_code, "get_lon_lat_lims.R"))
source(paste0(path_code, "show_trajectories.R"))
source(paste0(path_code, "do_pause.R"))
source(paste0(path_code, "depth_interp.R"))
source(paste0(path_code, "calc_auxil.R"))
source(paste0(path_code, "get_multi_profile_mean.R"))
source(paste0(path_code, "show_profiles.R"))
source(paste0(path_code, "plot_profiles.R"))
source(paste0(path_code, "show_sections.R"))
source(paste0(path_code, "plot_sections.R"))

packages<-c("gsw", "R.utils","Matrix")
f.ipak(packages)
rm(f.ipak, packages, path_code)
```



# functions
adapted, and thinned from ... script
```{r}

#

#function to create buffer around coastline
f.cl_buffer<-function(function_variables, cl){
  if(is.na(function_variables$land_buffer)==TRUE){
                      function_variables$land_buffer<-100000}
  y<-st_geometry(cl)
  y<-st_union(y, is_coverage = T)
  z<-st_centroid(y)
  land_buffer<-function_variables$land_buffer
  
  lat0<-z[[1]][2]
  lon0<-z[[1]][1]
  center.reproj<-paste0("+proj=aeqd +lat_0=", lat0, " ", "+lon_0=", lon0)
  flat<-sf::st_transform(y, center.reproj )
  buffered_land<-sf::st_buffer(flat, dist=land_buffer)%>%sf::st_transform(., "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0") 
  return(buffered_land)
}

# turn bgc-arg
f.profiles_to_points<-function(x){

y<-x$profiles
# z<-x$floats

f.select<-function(x){
  x<-x[y]
  return(x)
}
w<-lapply(Sprof, f.select) 
w<-as.data.frame(w)
w<-sf::st_as_sf(w, coords = c("lon","lat"), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
return(bgc_profiles.pts)
}


#### Match up for fro profile and float  inside EP TC zone

f.floats_within_EP<-function(function_variables){
end.date<-(function_variables$h_end_date+function_variables$h.post) %>% as.character(.)

if(is.na(function_variables$argo_sensor)==TRUE) {sensor_selection=NULL }
else {sensor_selection=function_variables$argo_sensor}

# only works for west (-) longitudes *improve here

total_floats<-select_profiles(lon_lim=c(function_variables$bgc.lon_max, function_variables$bgc.lon_min),lat_lim=c(function_variables$bgc.lat_min, function_variables$bgc.lat_max), end_date = end.date, start_date="1990-01-01", outside="none", sensor=sensor_selection)
return(total_floats) 
}

```


# Data 1
-Hurdat2
-- Hurricane tracks and wind speeds
---Bioargo r 
--Coastline data
## Read in "Best Track Data (HURDAT2)" hurricane data
Using/used 'hurdat package'

```{r}
#download from online. Basin is eastern pacific
#h<-get_hurdat(basin="EP")
#saveRDS(h, "r_objects/hurdat.R")

h<-readRDS("r_objects/hurdat.R")
h$DateTime<-with_tz(h$DateTime, tz="UTC")
```

## natural earth coastlines
source : https://www.naturalearthdata.com/downloads/10m-physical-vectors/10m-coastline/
version: 4.1.0
```{r}
setwd(gis_data)
# save shape files in named directory
coastline<-st_read("./ne_50m_land/ne_50m_land.shp") 
```


## Import BioArgo metadata (requires submodule install):

*** IMPORNAT ***
Hack to slect only 
```{r}
#initialize_argo() # downloads meta data for argo
#setwd(robj)
#save(Float, Setting, Sprof, sprof_update, file="init_argo.RData")
setwd(robj)
load("init_argo.RData")
```

# defining spatial bounds and fucntion variables
## Hurdat spatial/temporal bounds
- Hurricane zone defien as max, min of eastern basin Hurdat dtatset
-7 degrere bufer chosen becau of chen et al
-slecested 99% confidnec interval for altiduanl range to excluse northern outliers
```{r}
buffer=7

#west<-min(na.omit(h$Lon))-buffer
Lat.99<-quantile((na.omit(h$Lat)),probs=c(0.001,0.99)) # remove anonymous outliers otherwise hurricane zone is 70 N

west_argo=-180
north_tc<-(round_any(Lat.99[[2]], 0.5, f= round))
south_tc<-(round_any(Lat.99[[1]], 0.5, f= round))
east_tc<-round_any(max(na.omit(h$Lon[h$Lon < 0])), 0.5, f = round)


west_tc<-west_argo+buffer
north_argo<-north_tc+buffer 
south_argo<-south_tc-buffer
east_argo<-east_tc-buffer

# north<-max(na.omit(h$Lat))+buffer
# south<-min(na.omit(h$Lat))-buffer

print(min(na.omit(h$DateTime)))
print(max(na.omit(h$DateTime)))
print(c(north_argo, south_argo, west_argo, east_argo))

```

Add variables here

100km
200 km
500 km 

## function_variables (INCLUDES DYNAMIC VARIABLES based on Hurdat (h)):
Appending 'function_variables' with dynamic variables from hurdat 'h' data set
* originally from script "
* define here as opposed to within function or sub blocks
+ add hurdat coordinates as bbox feature

Note importance of "function_variables<-vector(mode="list")"

```{r}
function_variables<-vector(mode="list") # for storing all function variables that may be dynamic or other wise

### user defined: ####
# prior and post for time frame for argo profiles that fall within spatial selection window

#### spatial temporal secltion #####
# time
function_variables$h.prior<-30
function_variables$h.post<-45
## end date of hurricane database 
function_variables$h_end_date<- max(na.omit(h$DateTime)) %>% as.Date(.)

# space
function_variables$bgc.lon_max<-west_argo 
function_variables$bgc.lat_max<-north_argo
function_variables$bgc.lat_min<-south_argo
function_variables$bgc.lon_min<-east_argo

function_variables$tc.lon_max<-west_tc 
function_variables$tc.lat_max<-north_tc
function_variables$tc.lat_min<-south_tc
function_variables$tc.lon_min<-east_tc


# radius around TS in m
function_variables$tc.radi_1<-100000
function_variables$tc.radi_2<-200000
function_variables$tc.radi_3<-500000
function_variables$land_buffer<-200000

#### bgc-argo selection parameters ####
function_variables$year_begin<-1990

function_variables$argo_sensor<-NA 
#c("DOXY") #pick a single argo sensor, "TEMP", etc.)

function_variables$selection<-paste0("Lat (", function_variables$bgc.lat_min, ", ", function_variables$bgc.lat_max, ") Lon 
(", function_variables$bgc.lon_min, ", ", function_variables$bgc.lon_max,  ")")

```


# Float slection satistics
## step one square slection
```{r}
#slects profiles and floats within the  TC slection plus buffer does not remove coast

# Alter Sprof file

save_sprof<-Sprof
p<-which(Sprof$ocean =='P')

f.select<-function(x){
  x<-x[p]
  return(x)
}
Sprof<-lapply(Sprof, f.select)

function_variables$argo_sensor<-NA 
ep_total_floats<-f.floats_within_EP(function_variables)
function_variables$argo_sensor<-"DOXY"
ep_doxy_floats<-f.floats_within_EP(function_variables)

Sprof<-save_sprof
rm(save_sprof)

```
### summarry statitics
```{r}
print(length(na.omit(ep_total_floats$floats)))
print(length(na.omit(ep_total_floats$profiles)))


print(length(na.omit(ep_doxy_floats$floats)))
print(length(na.omit(ep_doxy_floats$profiles)))
```



# coastal float subsetting
## land buffer
```{r}
cl<-st_crop(coastline, xmin=function_variables$bgc.lon_min, ymin=function_variables$bgc.lat_min, xmax=function_variables$bgc.lon_max, ymax=function_variables$bgc.lat_max)
rm(coastline)

buffered_land<-f.cl_buffer(function_variables, cl)
rm(cl)
```
## profiles to sp object

```{r}

```


## remove profiles 


# Float TC match up
```{r}


```

```{r}

```

